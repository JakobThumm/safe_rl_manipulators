# Modrob Simulation
This package includes the `modrob_simulation` and modular robot MoveIt package(s).

## The `modrob_simulation` package
This package provides all necessary launch files, robot models, urdf files, the
simulation world, and the motion publisher.
See the packages README for greater detail.

## The `modrob_moveit_config` package
This package was autogenerated by the moveit setup wizard from `modrob0.urdf`.
It contains all launch and config files needed for a successful moveit integration.
However, we needed to change a few files with the help of [this tutorial](https://medium.com/@tahsincankose/custom-manipulator-simulation-in-gazebo-and-motion-planning-with-moveit-c017eef1ea90):
  1. In move_group.launch we added this argument in the top of the file
      ```
      <arg name="robot_name" default="modrob0"/>
      ```
      and then added this remap to the `move_group` node
      ```
      <remap from="joint_states" to="$(arg robot_name)/joint_states"/>
      ```
  2. Most importantly, we need to set up our desired controllers in `ros_controllers.yaml`.
      This file will be first loaded onto the ROS parameter server in the `modrob_simulation`
      launch files. We then spawn the ros controllers with the corresponding names.
      MoveIt needs controllers of the type `JointTrajectoryController`, and Gazebo
      states on their webpage, that they currently only support effort controllers,
      so we use a `type: effort_controllers/JointTrajectoryController` for MoveIt.
      ```
      arm_controller:
        type: effort_controllers/JointTrajectoryController
        joints:
          - joint0
          - joint1
          - joint2
        gains:
          joint0: {p: 5000.0, i: 0.0, d: 112.0}
          joint1: {p: 100000.0, i: 0.0, d: 0.0}
          joint2: {p: 700.0, i: 0.0, d: 0.0}
      gripper_controller:
        type: effort_controllers/JointTrajectoryController
        joints:
          - hand_to_finger1
          - hand_to_finger2
        gains:
          hand_to_finger1: {p: 1000.0, i: 0.0, d: 0.0}
          hand_to_finger2: {p: 1000.0, i: 0.0, d: 0.0}
      ```
      Controlling the robot with moveit is not desired in most RL scenarios, since
      moveit always has a small planning phase of ~ 0.1s. Therefore, we recommend
      to only use moveit if you plan an entire trajectory from start to goal position,
      for example for benchmarking or expert knowledge.
      For the regular RL operation we want to use a traditional PID controller.
      For this, we a arm and a gripper `JointGroupPositionController` to the `ros_controllers.yaml`.
      These controllers allow us to control the whole group at once, which is clearly
      beneficial to the single `JointPositionController`s because we always only
      need to spawn these two controllers, independently from the robots configuration.
      ```
      arm_position_controller:
        type: effort_controllers/JointGroupPositionController
        joints:
          - joint0
          - joint1
          - joint2
        joint0:
          pid: {p: 5000.0, i: 0.0, d: 112.0}
        joint1:
          pid: {p: 100000.0, i: 0.0, d: 0.0}
        joint2:
          pid: {p: 700.0, i: 0.0, d: 0.0}
      gripper_position_controller:
        type: effort_controllers/JointGroupPositionController
        joints:
          - hand_to_finger1
          - hand_to_finger2
        hand_to_finger1:
          pid: {p: 1000.0, i: 0.0, d: 0.0}
        hand_to_finger2:
          pid: {p: 1000.0, i: 0.0, d: 0.0}
      ```
      ROS doesn't allow us to use two controllers for the same resource (joint).
      Therefore, we spawn the `JointTrajectoryController`s normally and spawn the
      `JointGroupPositionController`s in stopped mode.
      (See `modrob_simulation/launch/put_robot_in_world.launch` and `modrob_simulation/launch/modrob_control.launch`). The robot controllers can be switched with
      ```
      rosservice call /modrob0/controller_manager/switch_controller "start_controllers: ['arm_position_controller', 'gripper_position_controller']
      stop_controllers: ['arm_controller', 'gripper_controller']
      strictness: 2
      start_asap: false
      ```
      In our RL code, we start with the moveit controllers to properly stertup MoveIt,
      and then switch to the traditional position controllers. MoveIt is still able
      to calculate forward and backward kinematics, output joint positions, and do
      a collision detection.
  3. Adjust the min/max position, velocity, and acceleration in `joint_limits.yaml`.
